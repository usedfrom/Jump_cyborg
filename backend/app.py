from flask import Flask, request, jsonify
from flask_cors import CORS
from telegram import Bot, Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes
import os
import requests
import json
import time
import asyncio
import logging
import base64
from dotenv import load_dotenv
import telegram

app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": "https://jump-cyborg.vercel.app"}})

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ python-telegram-bot
if telegram.__version__.split('.')[0] < '20':
    logger.error(f"–¢—Ä–µ–±—É–µ—Ç—Å—è python-telegram-bot >= 20.0, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≤–µ—Ä—Å–∏—è {telegram.__version__}")
    raise ImportError("–û–±–Ω–æ–≤–∏—Ç–µ python-telegram-bot –¥–æ –≤–µ—Ä—Å–∏–∏ >= 20.0")

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –∏ URL
BOT_TOKEN = os.getenv('BOT_TOKEN')
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
WEBAPP_URL = 'https://jump-cyborg.vercel.app/'

# –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —Ç–æ–∫–µ–Ω—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã
if not BOT_TOKEN:
    logger.error("BOT_TOKEN –Ω–µ —É–∫–∞–∑–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
    raise ValueError("BOT_TOKEN –Ω–µ —É–∫–∞–∑–∞–Ω")
if not GITHUB_TOKEN:
    logger.error("GITHUB_TOKEN –Ω–µ —É–∫–∞–∑–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
    raise ValueError("GITHUB_TOKEN –Ω–µ —É–∫–∞–∑–∞–Ω")

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è GitHub
GITHUB_REPO = 'usedfrom/Jump_cyborg'  # –£–∫–∞–∑–∞–Ω –≤–∞—à —Ä–µ–∞–ª—å–Ω—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
GITHUB_FILE_PATH = 'data/scores.json'
GITHUB_API_URL = f'https://api.github.com/repos/{GITHUB_REPO}/contents/{GITHUB_FILE_PATH}'
GITHUB_HEADERS = {
    'Authorization': f'token {GITHUB_TOKEN}',
    'Accept': 'application/vnd.github.v3+json',
    'User-Agent': 'JumpCyborgBot'
}

# –ü—Ä–æ–≤–µ—Ä–∫–∞ GITHUB_TOKEN
def validate_github_token():
    try:
        response = requests.get('https://api.github.com/user', headers=GITHUB_HEADERS)
        if response.status_code == 200:
            logger.info(f"GitHub —Ç–æ–∫–µ–Ω –≤–∞–ª–∏–¥–µ–Ω, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {response.json()['login']}")
            return True
        else:
            logger.error(f"–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π GITHUB_TOKEN: {response.status_code} {response.text}")
            return False
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ GITHUB_TOKEN: {e}")
        return False

if not validate_github_token():
    raise ValueError("–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π GITHUB_TOKEN, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
try:
    bot = Bot(token=BOT_TOKEN)
    application = Application.builder().token(BOT_TOKEN).build()
    logger.info("Telegram Bot —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
except Exception as e:
    logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Telegram Bot: {e}")
    raise

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ data (–ø—É—Å—Ç–æ–π —Ñ–∞–π–ª .gitkeep)
def create_data_folder():
    try:
        logger.info("–ü–æ–ø—ã—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞–ø–∫–∏ data —á–µ—Ä–µ–∑ .gitkeep")
        content = base64.b64encode(b'').decode('utf-8')
        payload = {
            'message': 'Create data folder with .gitkeep',
            'content': content,
            'branch': 'main'
        }
        response = requests.put(
            f'https://api.github.com/repos/{GITHUB_REPO}/contents/data/.gitkeep',
            headers=GITHUB_HEADERS,
            json=payload
        )
        if response.status_code in [200, 201]:
            logger.info("–ü–∞–ø–∫–∞ data —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞")
            return True
        else:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–∞–ø–∫–∏ data: {response.status_code} {response.text}")
            return False
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–∞–ø–∫–∏ data: {e}")
        return False

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è scores.json
def create_scores_file():
    try:
        logger.info("–ü–æ–ø—ã—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è scores.json")
        content = json.dumps([], indent=2)
        encoded_content = base64.b64encode(content.encode('utf-8')).decode('utf-8')
        payload = {
            'message': 'Create scores.json',
            'content': encoded_content,
            'branch': 'main'
        }
        response = requests.put(GITHUB_API_URL, headers=GITHUB_HEADERS, json=payload)
        if response.status_code in [200, 201]:
            logger.info("–§–∞–π–ª scores.json —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω")
            return response.json()['content']['sha']
        else:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ scores.json: {response.status_code} {response.text}")
            return None
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ scores.json: {e}")
        return None

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ JSON-—Ñ–∞–π–ª–∞ –∏–∑ GitHub
def get_scores_from_github():
    try:
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–∏–µ scores.json –∏–∑ {GITHUB_API_URL}")
        response = requests.get(GITHUB_API_URL, headers=GITHUB_HEADERS)
        logger.info(f"–û—Ç–≤–µ—Ç GitHub: {response.status_code}")
        if response.status_code == 200:
            file_data = response.json()
            content = base64.b64decode(file_data['content']).decode('utf-8')
            scores = json.loads(content)
            logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π: {len(scores)}")
            return scores, file_data['sha']
        elif response.status_code == 404:
            logger.warning("scores.json –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π")
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏ data
            folder_check = requests.get(
                f'https://api.github.com/repos/{GITHUB_REPO}/contents/data',
                headers=GITHUB_HEADERS
            )
            if folder_check.status_code == 404:
                logger.info("–ü–∞–ø–∫–∞ data –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞—ë–º")
                if not create_data_folder():
                    logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–∞–ø–∫—É data")
                    return [], None
            sha = create_scores_file()
            return [], sha
        else:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {response.status_code} {response.text}")
            return [], None
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
        return [], None

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è JSON-—Ñ–∞–π–ª–∞ –≤ GitHub
def save_scores_to_github(scores, sha):
    try:
        logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ {len(scores)} –∑–∞–ø–∏—Å–µ–π –≤ scores.json")
        content = json.dumps(scores, indent=2)
        encoded_content = base64.b64encode(content.encode('utf-8')).decode('utf-8')
        payload = {
            'message': 'Update scores.json',
            'content': encoded_content,
            'sha': sha if sha else None,
            'branch': 'main'
        }
        response = requests.put(GITHUB_API_URL, headers=GITHUB_HEADERS, json=payload)
        if response.status_code in [200, 201]:
            logger.info("–§–∞–π–ª scores.json —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω")
            return response.json()['content']['sha']
        else:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {response.status_code} {response.text}")
            return None
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
        return None

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–ö–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}")
    keyboard = [[InlineKeyboardButton("–ò–≥—Ä–∞—Ç—å", web_app={'url': WEBAPP_URL})]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text('–ù–∞–∂–º–∏ "–ò–≥—Ä–∞—Ç—å", —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!', reply_markup=reply_markup)
    logger.info("–ö–Ω–æ–ø–∫–∞ '–ò–≥—Ä–∞—Ç—å' –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞")

async def top(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–ö–æ–º–∞–Ω–¥–∞ /top –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}")
    try:
        scores, _ = get_scores_from_github()
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(scores)} –∑–∞–ø–∏—Å–µ–π –¥–ª—è /top")
        
        top_scores = sorted(scores, key=lambda x: x['score'], reverse=True)[:10]
        
        user_id = update.effective_user.id
        user_score = next((entry['score'] for entry in scores if entry['user_id'] == user_id), None)
        
        user_rank = None
        if user_score is not None:
            user_rank = sum(1 for entry in scores if entry['score'] > user_score) + 1
        
        message = 'üèÜ –¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤:\n'
        if top_scores:
            for i, entry in enumerate(top_scores, 1):
                username = entry['username'].replace('_', '\\_').replace('*', '\\*').replace('`', '\\`').replace('[', '\\[')
                message += f"{i}. {username}: {entry['score']}\n"
        else:
            message += '–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ –ø—É—Å—Ç–∞.\n'
        
        if user_score is not None:
            message += f'\n–í—ã –Ω–∞ {user_rank} –º–µ—Å—Ç–µ —Å {user_score} –æ—á–∫–∞–º–∏'
        else:
            message += '\n–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.'
        
        await update.message.reply_text(message, parse_mode='MarkdownV2')
        logger.info("–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ /top: {e}")
        await update.message.reply_text('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.')

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–ö–æ–º–∞–Ω–¥–∞ /help –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.effective_user.id}")
    message = (
        "üéÆ *JumpBot* ‚Äî –±–æ—Ç –¥–ª—è –∏–≥—Ä—ã Jump Cyborg!\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/start ‚Äî –ù–∞—á–∞—Ç—å –∏–≥—Ä—É, –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –∏–≥—Ä—É.\n"
        "/top ‚Äî –ü–æ–∫–∞–∑–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É –ª–∏–¥–µ—Ä–æ–≤ (—Ç–æ–ø-10 –∏–≥—Ä–æ–∫–æ–≤).\n"
        "/help ‚Äî –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n\n"
        f"–ò–≥—Ä–∞–π—Ç–µ –Ω–∞: {WEBAPP_URL}"
    )
    await update.message.reply_text(message, parse_mode='MarkdownV2')
    logger.info("–°–æ–æ–±—â–µ–Ω–∏–µ /help –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")

@app.route('/webhook', methods=['POST'])
async def webhook():
    try:
        update = Update.de_json(request.get_json(), bot)
        await application.process_update(update)
        return jsonify({'status': 'OK'})
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ webhook: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/save_score', methods=['POST'])
def save_score():
    data = request.get_json()
    logger.info(f"–ó–∞–ø—Ä–æ—Å /save_score: {json.dumps(data, indent=2)}")
    if not data or 'user_id' not in data or 'username' not in data or 'score' not in data:
        logger.error("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
        return jsonify({'status': 'error', 'message': 'Invalid data'}), 400
    
    user_id = data['user_id']
    username = data['username']
    score = data['score']
    
    try:
        scores, sha = get_scores_from_github()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        existing_entry = next((entry for entry in scores if entry['user_id'] == user_id), None)
        
        if existing_entry:
            existing_entry['username'] = username
            existing_entry['score'] = score
            logger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω —Å—á—ë—Ç: user_id={user_id}, username={username}, score={score}")
        else:
            scores.append({'user_id': user_id, 'username': username, 'score': score})
            logger.info(f"–ù–æ–≤—ã–π —Å—á—ë—Ç: user_id={user_id}, username={username}, score={score}")
        
        new_sha = save_scores_to_github(scores, sha)
        if new_sha:
            logger.info("–°—á—ë—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω")
            return jsonify({'status': 'OK'})
        else:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—á—ë—Ç –≤ GitHub")
            return jsonify({'status': 'error', 'message': 'Failed to save score to GitHub'}), 500
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ /save_score: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/get_leaderboard_with_rank', methods=['GET'])
def get_leaderboard_with_rank():
    logger.info("–ó–∞–ø—Ä–æ—Å /get_leaderboard_with_rank")
    user_id = request.args.get('user_id', type=int)
    current_score = request.args.get('score', type=int, default=0)
    logger.info(f"–ü–∞—Ä–∞–º–µ—Ç—Ä—ã: user_id={user_id}, score={current_score}")
    
    try:
        scores, _ = get_scores_from_github()
        logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(scores)} –∑–∞–ø–∏—Å–µ–π")
        
        top_scores = sorted(scores, key=lambda x: x['score'], reverse=True)[:10]
        logger.info(f"–í–æ–∑–≤—Ä–∞—â–µ–Ω–æ —Ç–æ–ø-10: {json.dumps(top_scores, indent=2)}")
        
        user_rank = None
        if user_id:
            user_score = next((entry['score'] for entry in scores if entry['user_id'] == user_id), None)
            effective_score = max(user_score, current_score) if user_score is not None else current_score
            user_rank = sum(1 for entry in scores if entry['score'] > effective_score) + 1
            logger.info(f"–†–∞–Ω–≥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user_rank}, —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π —Å—á—ë—Ç: {effective_score}")
        
        response = {'status': 'OK', 'leaderboard': top_scores, 'user_rank': user_rank}
        logger.info(f"–û—Ç–≤–µ—Ç –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞: {json.dumps(response, indent=2)}")
        return jsonify(response)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ /get_leaderboard_with_rank: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

async def run_polling_with_retry():
    max_retries = 5
    retry_delay = 10  # —Å–µ–∫—É–Ω–¥
    attempt = 0
    
    while attempt < max_retries:
        try:
            logger.info(f"–ó–∞–ø—É—Å–∫ polling, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}")
            await application.run_polling()
            logger.info("Polling Telegram Bot —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω")
            break
        except Exception as e:
            attempt += 1
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ polling (–ø–æ–ø—ã—Ç–∫–∞ {attempt}): {e}")
            if attempt < max_retries:
                logger.info(f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ {retry_delay} —Å–µ–∫—É–Ω–¥")
                await asyncio.sleep(retry_delay)
            else:
                logger.error("–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫, polling –Ω–µ –∑–∞–ø—É—â–µ–Ω")
                raise

def main():
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('top', top))
    application.add_handler(CommandHandler('help', help_command))
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º polling –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –∑–∞–¥–∞—á–µ
    loop = asyncio.get_event_loop()
    loop.create_task(run_polling_with_retry())

if __name__ == '__main__':
    port = int(os.getenv('PORT', 10000))
    logger.info(f"–ó–∞–ø—É—Å–∫ Flask —Å–µ—Ä–≤–µ—Ä–∞ –Ω–∞ –ø–æ—Ä—Ç—É {port}")
    app.run(host='0.0.0.0', port=port)
